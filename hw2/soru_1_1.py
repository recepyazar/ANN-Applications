import numpy as np
import random
import math
from math import sqrt
from matplotlib import pyplot as plt
#Eğitim verisini oluşturan fonksiyon
def create_train():
    """Datasetimiz 3, y, + ve 1 den oluşmaktadır. Train datasında her bir 
    sınıf için 1 orijinal, 4 gürültülü, 4 bit hatalı olmak üzere 9 data vardır. 
    Yani toplamda eğitim datası 4 * 9 = 36 elemandan oluşmaktadır."""
    #Train data matrislerinden oluşan liste
    #-----------------------------------------------------------
    #Orijinal 3, 4 adet noise eklenmiş hali ve 4 adet bit hatası eklenmiş hali
    train_matrixes = [np.matrix([[0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.23607427, 0.12619118, 0.07276889, 0.96527562, 1.01011875, 1.1030343, 0.16573573, 0.09502542, 0.07399193, 0.11718877],
    [0.21908869, 0.09760164, 0.08746364, 0.07092201, 0.22749557, 1.06504898, 0.17641611, 0.06256097, 0.21474379, 0.23360033],
    [0.14137598, 0.05028969, 0.12056787, 1.13950565, 0.97505836, 1.03486723, 0.17044353, 0.22883595, 0.14633285, 0.12873279],
    [0.14931279, 0.06855984, 0.13410405, 0.2133266,  0.06036452, 0.97752225, 0.23960634, 0.08405042, 0.11098154, 0.19439116],
    [0.11833987, 0.17801798, 0.13983995, 1.10539823, 1.106674,   1.1154426, 0.1909154,  0.16279701, 0.21263374, 0.10444211]]),
    np.matrix([[0.22388216, 0.11246167, 0.19069038, 0.98155686, 1.07831996, 1.13502188, 0.22920046, 0.15903914, 0.17930273, 0.11369083],
    [0.23483815, 0.08756337, 0.22062194, 0.16225838, 0.24122561, 1.07842535, 0.12196859, 0.07439979, 0.17878739, 0.07837988],
    [0.12853343, 0.09842509, 0.13725485, 1.10026319, 1.07750274, 1.12867232, 0.08559654, 0.18340444, 0.09843487, 0.10979585],
    [0.14995816, 0.17637843, 0.10473044, 0.21406187, 0.06705415, 0.95568542, 0.0704115,  0.21191844, 0.09852725, 0.22983072],
    [0.11575614, 0.12621528, 0.16319651, 1.00901941, 0.96529989, 1.14136366, 0.13201059, 0.23602914, 0.11472478, 0.1221078]]),
    np.matrix([[0.21657088, 0.20545685, 0.15183158, 1.0277128,  1.10347107, 1.13704711, 0.18738423, 0.12151782, 0.09355139, 0.19242499],
    [0.22389164, 0.15858336, 0.17522453, 0.20222681, 0.2314012, 0.97412525, 0.24191081, 0.10586085, 0.17455419, 0.24650989],
    [0.12320395, 0.09614227, 0.18638834, 0.98872839, 1.04804627, 1.14604949, 0.19190619, 0.05684675, 0.18537662, 0.15706777],
    [0.18621254, 0.08496535, 0.13952724, 0.17880953, 0.19037357, 0.97039767, 0.05528016, 0.10340874, 0.11913285, 0.06442716],
    [0.12237712, 0.07742875, 0.20853032, 0.95952046, 1.04659791, 1.08965902, 0.06989142, 0.1257024,  0.22281968, 0.0800065]]),
    np.matrix([[0.17744261, 0.22369301, 0.23272082, 1.04236308, 1.00250087, 1.11653834, 0.12839307, 0.14885925, 0.23747215, 0.11299405],
    [0.24697544, 0.12626741, 0.20479184, 0.08964658, 0.09834717, 1.063112  , 0.1020325 ,  0.16350105, 0.13160302, 0.20429148],
    [0.05028516, 0.19817747, 0.20317857, 0.98215026, 1.14982114, 0.99650037, 0.05312647, 0.06481028, 0.18583445, 0.16024221],
    [0.13420251, 0.19531486, 0.06881379, 0.24450378, 0.06067559, 0.97958093, 0.16071817, 0.09772669, 0.06003264, 0.1010753 ],
    [0.13139487, 0.10703501, 0.05894121, 1.09498539, 1.04909036, 0.99351304, 0.12772428, 0.12335695, 0.12609734, 0.23575643]]),
    np.matrix([[0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.95],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.95, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.95, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    #Orijinal 1, 4 adet noise eklenmiş hali ve 4 adet bit hatası eklenmiş hali
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.23318949, 0.18748095, 0.16542534, 0.09060646, 0.99937188, 0.22770327, 0.12662677, 0.20058673, 0.09583247, 0.15500469],
    [0.16842678, 0.12326432, 0.22823526, 0.98499643, 1.12193654, 0.24743549, 0.05437593, 0.09959451, 0.07378983, 0.14100341],
    [0.10154137, 0.07750037, 0.22023276, 0.05350862, 1.03977734, 0.09290559, 0.20298743, 0.19757612, 0.20052093, 0.06597319],
    [0.06199779, 0.05639082, 0.12587637, 0.20435562, 0.9700394 , 0.22280154, 0.15030874, 0.22885328, 0.18267506, 0.21649729],
    [0.19531407, 0.08966026, 0.22110573, 1.04657223, 0.95064998, 1.08558298, 0.15736368, 0.20916273, 0.22539033, 0.12301805]]),
    np.matrix([[0.1272307,  0.17721,    0.07581146, 0.16011008, 1.04500983, 0.07350023, 0.20716542, 0.23092454, 0.05014498, 0.17921139],
    [0.21629988, 0.24252284, 0.18542147, 0.96192193, 1.14411264, 0.12637014, 0.17010937, 0.23130788, 0.20336762, 0.23085278],
    [0.20984675, 0.23072475, 0.07962799, 0.07129788, 1.05666043, 0.19121837, 0.1792837 , 0.13307303, 0.05579356, 0.05164822],
    [0.24691175, 0.21900202, 0.17666181, 0.23107033, 1.01201108, 0.18534505, 0.15140981, 0.24121854, 0.17401274, 0.14475414],
    [0.06899441, 0.07060948, 0.21276631, 1.11499716, 1.05089084, 1.09724192, 0.13916945, 0.22783695, 0.19466235, 0.14621707]]),
    np.matrix([[0.23173155, 0.24028001, 0.11306575, 0.12293885, 1.10614906, 0.15442259, 0.21442705, 0.19784124, 0.20475456, 0.2232313 ],
    [0.21519897, 0.24774738, 0.154172  , 1.01357136, 0.98993933, 0.19668817, 0.14549993, 0.06883018, 0.20515087, 0.2459543 ],
    [0.1331499,  0.18539162, 0.13627571, 0.23378216, 1.07702208, 0.06918127, 0.08281712, 0.12963657, 0.20773468, 0.1849902 ],
    [0.10005321, 0.05561786, 0.14795564, 0.10619624, 1.07200257, 0.16900807, 0.22421666, 0.19100679, 0.14335985, 0.23083014],
    [0.228467,   0.11772192, 0.23620684, 0.98549201, 0.96721191, 0.99299047, 0.07056388, 0.18596664, 0.21045904, 0.20417312]]),
    np.matrix([[0.15593815, 0.17797911, 0.19020534, 0.17384832, 1.06287824, 0.14290783, 0.22365939, 0.16663095, 0.08056981, 0.16550915],
    [0.12527172, 0.14347316, 0.09605026, 0.98662629, 1.13949564, 0.0790411 , 0.06065262, 0.0656605 , 0.08467348, 0.08570999],
    [0.13908819, 0.07225993, 0.0950871 , 0.16392348, 0.96476846, 0.20407396, 0.19307519, 0.17036988, 0.1386692 , 0.18892863],
    [0.0672324,  0.22925412, 0.17868238, 0.14115868, 0.96356959, 0.21739149, 0.16181325, 0.17163452, 0.22023902, 0.23780982],
    [0.0874828,  0.19856299, 0.20839768, 0.95079199, 1.04053074, 1.06842463, 0.05531293, 0.2403948 , 0.22142398, 0.08628335]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.95, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]), 
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.95, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.95, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05 ,0.05 ,0.05 ,0.95 ,0.95 ,0.05 ,0.05 ,0.05 ,0.05 ,0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    #Orijinal y, 4 adet noise eklenmiş hali ve 4 adet bit hatası eklenmiş hali
    np.matrix([[0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05], 
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.1064579 , 0.11108002, 0.99173137, 0.19119455, 0.10200194, 0.1203633 ,1.04290756 ,0.15006937 ,0.2065824, 0.20236357],
    [0.14038047, 0.20800351, 0.09612474, 1.1092066 , 0.05622245, 1.13802974, 0.15739208, 0.07830018, 0.11265558, 0.15490313],
    [0.07603411, 0.20067565, 0.08973948, 0.11726099, 1.00224674, 0.1504946 , 0.08703564, 0.09148584, 0.20376455, 0.1339158],
    [0.18140986, 0.10777211, 0.07968004, 0.09173005, 1.02989306, 0.10144379, 0.15236173, 0.170447  , 0.20256922, 0.19460265],
    [0.09669842, 0.0629027 , 0.05962492, 0.2421696 , 1.09018002, 0.21299216, 0.07533056, 0.19227327, 0.19268855, 0.16400533]]),
    np.matrix([[0.23018847, 0.12353678, 1.1397233 , 0.22201844, 0.07051151, 0.2309947 ,1.09212338 ,0.13296118 ,0.12553416, 0.22202964],
    [0.23123364, 0.20055193, 0.07122445, 1.13860916, 0.21074705, 0.98825263, 0.19094834, 0.17575216, 0.15430377, 0.2227573],
    [0.06292849, 0.21930893, 0.23766321, 0.19291989, 1.11396173, 0.21863095, 0.12430778, 0.05557578, 0.05993201, 0.15368395],
    [0.10464925, 0.22726586, 0.20813932, 0.1401267 , 0.98851356, 0.24409596, 0.14141344, 0.12566608, 0.09646833, 0.15449149],
    [0.21294613, 0.22314126, 0.12859276, 0.11055338, 1.02619313, 0.22803097, 0.06168351, 0.07403275, 0.14245663, 0.20086876]]),
    np.matrix([[0.15670423, 0.23674716, 1.11997059, 0.05780199, 0.19358744, 0.06701713, 0.97313167, 0.22010192, 0.13253729, 0.23911341],
    [0.07444843, 0.06960323, 0.09518468, 1.11125817, 0.22806514, 1.04979548, 0.20279996, 0.18430666, 0.22819992, 0.10642259],
    [0.09530101, 0.14008826, 0.09654815, 0.13455519, 1.0403036 , 0.2006044 ,0.11725259 ,0.21411542 ,0.11970058 ,0.12361821],
    [0.15150936, 0.24462569, 0.0672617 , 0.05966504, 1.12138693, 0.06085204, 0.1748993 , 0.05172375, 0.09012356, 0.13880355],
    [0.24872293, 0.12678478, 0.18398415, 0.13462024, 0.97203722, 0.13332167, 0.08976146, 0.09124093, 0.21720516, 0.09362848]]),
    np.matrix([[0.05667863, 0.20111845, 1.02448134, 0.19898411, 0.24961796, 0.15854447, 0.99991477, 0.24697529, 0.07990099, 0.22508839],
    [0.19964492, 0.12940902, 0.22067215, 0.95744409, 0.23542586, 1.02338256, 0.24129861, 0.18573186, 0.05265749, 0.12516687],
    [0.12389874, 0.20055131, 0.12809452, 0.1813405 , 1.12050923, 0.13781057, 0.1441484 , 0.16589907, 0.13986898, 0.1045064],
    [0.14821727, 0.14235795, 0.15114378, 0.1752771 , 0.973169  , 0.15717777, 0.19652609, 0.24261317, 0.19430331, 0.21503813],
    [0.221696,   0.16711797, 0.20309856, 0.18623561, 1.11856559, 0.15801766, 0.19163373, 0.08543957, 0.13859369, 0.14597431]]),
    np.matrix([[0.05, 0.05, 0.95, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.95],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.95, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    #Orijinal +, 4 adet noise eklenmiş hali ve 4 adet bit hatası eklenmiş hali
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.1916448 , 0.07167863, 0.22867751, 0.11605899, 1.14877557, 0.11329521, 0.18814565, 0.20117405, 0.21718965, 0.16932023],
    [0.1544599,  0.2410344 , 0.12309248, 0.09333966, 0.95829697, 0.13725788, 0.15680487, 0.06471766, 0.22446953, 0.11132526],
    [0.11764597, 0.0733685 , 0.99330962, 1.03624059, 1.10073349, 1.1244952 ,0.99729138 ,0.15943496 ,0.1477933  ,0.21038369],
    [0.24417101, 0.19431552, 0.18324488, 0.22997443, 0.98113239, 0.12100732, 0.16576546, 0.14132894, 0.1527418 , 0.20990948],
    [0.12909018, 0.11983287, 0.08461382, 0.2118933 , 0.98641654, 0.2149036 ,0.05746501 ,0.22756783, 0.16139173 , 0.0803947]]),
    np.matrix([[0.14112354, 0.2150752,  0.13997997, 0.169367, 1.02501795, 0.21857621, 0.24401317, 0.24817778, 0.20765166, 0.06238939],
    [0.22193527, 0.20123377, 0.08701262, 0.13454782, 1.03478972, 0.09508203, 0.1331525,  0.11021268, 0.0774169,  0.19185895],
    [0.1988226,  0.07498427, 0.99617415, 0.97648575, 0.96413431, 0.96787567, 1.05475555, 0.11770768, 0.15405446, 0.10453505],
    [0.24209437, 0.06277064, 0.19637938, 0.09567091, 0.98591687, 0.19535419, 0.15403505, 0.15910603, 0.15358562, 0.09586477],
    [0.10313207, 0.0762772,  0.19004644, 0.05785228, 1.09968114, 0.2383894,  0.10040431, 0.119165,   0.12233379, 0.18312213]]),
    np.matrix([[0.09140412, 0.1377111,  0.16803023, 0.18666874, 1.11684786, 0.16838064, 0.15691459, 0.16499168, 0.24074752, 0.21590288],
    [0.18831302, 0.10735879, 0.20704637, 0.12940783, 0.95617314, 0.10341456, 0.09017523, 0.20793423, 0.0743366 , 0.12934781],
    [0.12740241, 0.0948128 , 1.11556315, 1.07662184, 1.07621979, 1.08147774, 1.06382943, 0.17633851, 0.17183413, 0.18974787],
    [0.10638238, 0.07969815, 0.16639766, 0.16322625, 1.13781047, 0.11133865, 0.10410468, 0.1817311 , 0.23461489, 0.19393374],
    [0.06371773, 0.05147909, 0.07307368, 0.14893528, 1.00651247, 0.16326091, 0.0643154 , 0.15561584, 0.06279157, 0.06835037]]),
    np.matrix([[0.18625973, 0.11301008, 0.11413247, 0.11945224, 1.14275498, 0.11736042, 0.05842687, 0.05607495, 0.13992096, 0.17040002],
    [0.17074377, 0.1797918 , 0.1431345 , 0.09238329, 1.13431467, 0.08655205, 0.11431549, 0.15012151, 0.06236446, 0.10755925],
    [0.17725012, 0.2269235 , 1.1191423 , 0.99063916, 0.9666335 , 1.01632456, 0.98528288, 0.20855689, 0.10598314, 0.23894173],
    [0.13708027, 0.07331624, 0.16973254, 0.11621966, 0.95424155, 0.17479803, 0.21036803, 0.06536317, 0.13271373, 0.09210745],
    [0.20573019, 0.23264935, 0.06262805, 0.22134243, 0.96762175, 0.10048641, 0.06372988, 0.14492664, 0.06208526, 0.17710593]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.95, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.95, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]])]

    #Vektöre çevirilmiş hallerini tutacak array 
    train_vectors = []
    #data ile beraber targetı da tutan tipte (data_with_class classı) tutacak liste
    train_data = []
    #Classlar için target atamaları
    class_3 = np.array([1,0,0,0])
    class_1 = np.array([0,1,0,0])
    class_y = np.array([0,0,1,0])
    class_P = np.array([0,0,0,1])
    for i in range(len(train_matrixes)):
        #Data matristen vektöre çeviriliyor
        train_vectors.append(np.transpose(np.reshape(train_matrixes[i],-1)))
        #Indexine göre data vektörü target ile beraber nihai data listesine ekleniyor
        if i <= ((len(train_matrixes)/4)-1):
            train_data.append(data_with_class(train_vectors[i],class_3))
        elif i <= (2*(len(train_matrixes)/4)-1):
            train_data.append(data_with_class(train_vectors[i],class_1))
        elif i <= (3*(len(train_matrixes)/4)-1):
            train_data.append(data_with_class(train_vectors[i],class_y))
        else:
            train_data.append(data_with_class(train_vectors[i],class_P))
    #Fonksiyon niihai train_data listesini döndürüyor
    return train_data
#Test verisini oluşturan fonksiyon
def create_test():
    """Datasetimiz 3, y, + ve 1 den oluşmaktadır. Test datasında her bir 
    sınıf için 2 gürültülü, 2 bit hatalı olmak üzere 4 data vardır. 
    Yani toplamda test datası 4 * 4 = 16 elemandan oluşmaktadır."""
    #Test data matrislerinden oluşan liste
    #-----------------------------------------------------------
    #2 adet noise eklenmiş ve 2 adet bit hatası eklenmiş "3"
    test_matrixes = [np.matrix([[0.21246776, 0.19443899, 0.12964419, 1.05707462, 1.03521729, 0.96585546, 0.16928659, 0.23749404, 0.1549621, 0.14464568],
    [0.23171389, 0.10594082, 0.18644099, 0.14337584, 0.17068212, 1.02679658, 0.24351594, 0.10976914, 0.16607162, 0.1066909],
    [0.11753598, 0.21097697, 0.14926522, 1.13132359, 1.03619397, 1.04738404, 0.18298337, 0.08783172, 0.20294874, 0.0554743],
    [0.23955969, 0.19296448, 0.09605566, 0.13812772, 0.1851741 , 1.074757, 0.19494514, 0.15300173, 0.21837448, 0.19156158],
    [0.24716323, 0.22422559, 0.2458226 , 1.03471559, 1.11000046, 1.02071169, 0.11836327, 0.12157207, 0.15818423, 0.13962173]]),
    np.matrix([[0.19436152, 0.14387833, 0.08754524, 1.1239549,  1.14766505, 1.04063373, 0.07924924, 0.17937325, 0.08242709, 0.0928772],
    [0.16589525, 0.07976354, 0.06997242, 0.14356839, 0.23995745, 1.08711222, 0.17919873, 0.09053577, 0.08321907, 0.21474084],
    [0.19248522, 0.21545402, 0.12776091, 1.04225756, 0.97514567, 1.05410427, 0.06254869, 0.09531618, 0.15944605, 0.20033767],
    [0.18776246, 0.17576903, 0.0857699 , 0.12341808, 0.16607572, 1.02314279, 0.09728126, 0.08490087, 0.06027754, 0.17716304],
    [0.15949639, 0.11514712, 0.24885347, 0.99430993, 1.12110029, 1.12993676, 0.1639655,  0.06987175, 0.10128193, 0.21563075]]),
    np.matrix([[0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.95]]),
    np.matrix([[0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    #2 adet noise eklenmiş ve 2 adet bit hatası eklenmiş "1"
    np.matrix([[0.19810705, 0.06304415, 0.18452295, 0.23136222, 0.99059337, 0.24169199, 0.1872265 , 0.12554051, 0.12773596, 0.05797447],
    [0.14150625, 0.10888249, 0.17254973, 0.98955297, 1.05444379, 0.12695568, 0.24857829, 0.18250547, 0.1689605 , 0.13554147],
    [0.23420387, 0.07028972, 0.22017918, 0.1876069 , 1.0538914 , 0.16460023, 0.20301221, 0.10758159, 0.17866784, 0.08504779],
    [0.16685939, 0.07068502, 0.2378187 , 0.18050225, 1.05725856, 0.0617921 ,0.14674455 ,0.08826586 ,0.1607386  ,0.13444653],
    [0.23696108, 0.10276556, 0.20191885, 1.07748966, 1.02327365, 1.09063025, 0.16127394, 0.2024034 , 0.21651915, 0.24232572]]),
    np.matrix([[0.1105085 , 0.07822304, 0.13702758, 0.23254165, 0.9808798 ,0.09456506 ,0.19127613 ,0.18652938 ,0.05089099, 0.20647415],
    [0.18179918, 0.08643557, 0.13880494, 1.05091636, 1.0913547 , 0.10473396, 0.07767108, 0.07797222, 0.1991857 , 0.06102493],
    [0.06428824, 0.2267339 , 0.06057233, 0.20658606, 0.99388432, 0.21487868, 0.10937267, 0.21820467, 0.07710292, 0.11762908],
    [0.23414989, 0.19274241, 0.16858441, 0.15730908, 1.07561761, 0.06933776, 0.2138865 , 0.1291964 , 0.09719877, 0.20284948],
    [0.12573334, 0.20421778, 0.19957845, 0.98167345, 0.96767764, 1.00383493, 0.07111362, 0.05985561, 0.12088006, 0.17685727]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.95, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05, 0.05]]),
    #2 adet noise eklenmiş ve 2 adet bit hatası eklenmiş "y"
    np.matrix([[0.12754433, 0.06099344, 0.9990614, 0.21655222, 0.11809348, 0.19294962, 0.98857488, 0.10358211, 0.17032076, 0.18980585],
    [0.14953706, 0.13691116, 0.11514626, 1.01361884, 0.13931124, 0.98618546, 0.11071974, 0.16729185, 0.09438825, 0.1798213],
    [0.19418998, 0.20748544, 0.08847625, 0.14836652, 1.06778817, 0.17416435, 0.23732422, 0.06424075, 0.19394291, 0.21427235],
    [0.16541092, 0.05688803, 0.06381234, 0.14645646, 1.13732911, 0.21796829, 0.24026505, 0.13942765, 0.11047968, 0.16142584],
    [0.17117591, 0.18451149, 0.09889695, 0.21690601, 1.10439438, 0.16468396, 0.23920651, 0.22121378, 0.11945028, 0.23634678]]),
    np.matrix([[0.21852869, 0.14135445, 1.07435645, 0.20146319, 0.24534092, 0.16156763, 0.99966598, 0.20990943, 0.18946032, 0.16095657],
    [0.07239486, 0.15160873, 0.14873802, 1.05815451, 0.24606284, 1.12352247, 0.07034326, 0.06336081, 0.10278876, 0.15044956],
    [0.10006701, 0.22843676, 0.15814183, 0.12091346, 1.13607861, 0.10243464, 0.0720239 , 0.16503173, 0.05252555, 0.14205637],
    [0.18563487, 0.05531779, 0.05298179, 0.18501159, 0.95847571, 0.19645409, 0.15577101, 0.23068826, 0.14301655, 0.13508368],
    [0.19844969, 0.17666171, 0.08996253, 0.22643256, 1.09161186, 0.14812204, 0.05466332, 0.11844947, 0.10778719, 0.17839432]]),
    np.matrix([[0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.95, 0.95, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    #2 adet noise eklenmiş ve 2 adet bit hatası eklenmiş "+"
    np.matrix([[0.1102652 , 0.13530111, 0.08809543, 0.19875776, 1.11523467, 0.17653018, 0.20840605, 0.20055756, 0.06678684, 0.12090629],
    [0.1514241,  0.19545267, 0.14633379, 0.10711208, 0.95531001, 0.15687024, 0.22066357, 0.18124765, 0.07346222, 0.23051034],
    [0.22255003, 0.1740454 , 1.02132858, 1.06083691, 1.0302038 , 1.11893976, 1.02793534, 0.16937435, 0.0735962 , 0.10324005],
    [0.147517 ,  0.06171983, 0.24375339, 0.08752284, 1.09658056, 0.24246865, 0.11724662, 0.18876161, 0.09758025, 0.13397091],
    [0.2457416,  0.16280109, 0.10610261, 0.23125909, 1.0569538 , 0.1173083 ,0.23002968 ,0.1000782  ,0.17910467 ,0.10899753]]),
    np.matrix([[0.08308718, 0.1044753 , 0.21576909, 0.07282619, 0.97596806, 0.07970331, 0.17483482, 0.05773833, 0.15299216, 0.21947657],
    [0.09321289, 0.18393259, 0.08104531, 0.1076301 , 1.1370338 , 0.05459875, 0.2371227 , 0.22333784, 0.22614043, 0.07325601],
    [0.16750645, 0.24875609, 1.04377846, 1.02041035, 1.07472194, 1.10149428, 1.14182191, 0.12830676, 0.10078657, 0.090672  ],
    [0.06033428, 0.22204461, 0.13643272, 0.12481034, 1.03098056, 0.06987182, 0.21608022, 0.11397443, 0.20418001, 0.14518056],
    [0.10967607, 0.13539326, 0.15467533, 0.20304002, 1.14487852, 0.23944589, 0.05629207, 0.17450066, 0.20027509, 0.0759313 ]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.95, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]]),
    np.matrix([[0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.95],
    [0.05, 0.05, 0.95, 0.95, 0.95, 0.95, 0.95, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05],
    [0.05, 0.05, 0.05, 0.05, 0.95, 0.05, 0.05, 0.05, 0.05, 0.05]])]
    #Vektöre çevirilmiş hallerini tutacak array 
    test_vectors = []
    #Data ile beraber targetı da tutan tipte datayı tutacak liste
    test_data = []
    #Classlar için target atamaları
    class_3 = np.array([1,0,0,0])
    class_1 = np.array([0,1,0,0])
    class_y = np.array([0,0,1,0])
    class_P = np.array([0,0,0,1])
    for i in range(len(test_matrixes)):
        #Data matristen vektöre çeviriliyor
        test_vectors.append(np.transpose(np.reshape(test_matrixes[i],-1)))
        #Indexine göre data vektörü target ile beraber nihai data listesine ekleniyor
        if i <= ((len(test_matrixes)/4)-1):
            test_data.append(data_with_class(test_vectors[i],class_3))
        elif i <= (2*(len(test_matrixes)/4)-1):
            test_data.append(data_with_class(test_vectors[i],class_1))
        elif i <= (3*(len(test_matrixes)/4)-1):
            test_data.append(data_with_class(test_vectors[i],class_y))
        else:
            test_data.append(data_with_class(test_vectors[i],class_P))
    #Fonksiyon niihai test_data listesini döndürüyor
    return test_data
#a parametresi sigmoid ve türevinde katsayı olarak kullanılıyor (f(x) = sgm(a*x))
def sigmoid(x,a = 1):
        return 1 / (1 + math.exp(-x*a))
def sigmoid_derivative(x,a = 1):
        return a * math.exp(-a*x) / (1 + math.exp(-x*a))**2
#Tek bir nöronu modelleyen class
class neuron(object):
    def __init__(self,imput, weights): 
        self.imput = imput
        self.weights = weights
    #Giriş vektörünü ve ağırlıkların nokta çarpımını döndüren metod
    def dp(self):
        return self.imput.dot(self.weights)
    #Nokta çarpımını sigmoide sokan metod
    def out(self):
        self.y = sigmoid(self.dp(),5)
        return self.y
#Bir katmanı modelleyen class yapısı, neuron classı içinde kullanılıyor 
class hidden_layer(object):
    #init metodu, weighsi matris olarak alır, nörın sayısını alır, nöronları tutacağı boş bir liste oluşturur
    def __init__(self,imput,weights,neuron_count):
        self.imput = imput
        self.weights = weights
        self.neuron_count = neuron_count 
        self.neurons = [] 
    #İleri yayılım metodu
    def ffw(self):
        #Giriş vektörünün sonuna bias eklenir
        self.with_bias = np.insert(self.imput,len(self.imput),1)
        #Katman çıkış vektörü sıfırlardan oluşturulur
        self.out = np.zeros(self.neuron_count)
        #Nöron sayısı kadar dönen for döngüsü, nöron oluşturulur ve çıkışı katman çıkışı listesine eklenir
        for i in range(self.neuron_count):
            self.neurons.append(neuron(self.with_bias,self.weights[i][:]))
            self.out[i] = self.neurons[i].out()           
        return self.out
    #Daha sonra kullanılabileceği için nöron listesini döndüren metod
    def Neurons(self):
        return self.neurons
#Çok katmanlı algılayıcı classı
class ml_per(object):
    #init metodu, öğrenme hızı ve maksimum iterasyon sayısını alır
    def __init__(self,c,iteration):
        self.iteration = iteration
        self.c = c
        self.weights = []
    #Eğitim metodu, eğitilecek datayı, algılayıcı şeklini ve momentum katsayısını alır
    """Algılayıcı şekli array tipindedir, arrayin ilk elemanı giriş sayısını, son elemanı öıkış sayısını,
    aradaki elemanlar aradaki katmanların nöron sayısını belirler. Bu sayede katman sayısı ve katmanlardaki nöron
    sayısı iateğe göre değiştirilebilir."""
    def train(self,train_data,structure,momentum):
        #Her data için çıkıştaki error vektörünü tutar
        error_vectors = np.zeros((structure[len(structure)-1],len(train_data)))
        #Her data için çıkıştaki error vektöründen hesaplanan ortalama hatayı tutar
        mean_errors = []
        self.weights_difference = []
        #Ağırlıklar olusturuluyor
        for i in range(len(structure)-1):
            self.weights.append(np.random.normal(0,sqrt(1/structure[i]),(structure[i+1],structure[i]+1)))
            self.weights_difference.append(np.zeros((structure[i+1],structure[i]+1)))
        #Iterasyonları yapan for döngüsü
        stop = 0
        for a in range(self.iteration):
            mean_errors = np.zeros(len(train_data))
            #Iterasyon içinde her datayı eğiten for döngüsü
            for j in range(len(train_data)):
                #Geriye yayılımda kullanılacak parametreleri tutacak boş listeler
                all_derivatives = []
                derivatives = []
                last_derivatives = []
                all_gradients = []
                gradients = []
                last_gradients = []
                #Başlangıçta ilk data out olarak tanımlanıyor
                out = train_data[j].data 
                #Geriye yayılımda kullanmak için her katmandaki nöronları ve katman çıkışlarını tutan boş listeler
                all_neurons = []
                all_outs = []
                all_outs.append(out)
                #İLERİ YAYILIM
                #İleri yayılım algoritası yapılan for döngüsü
                for k in range(len(structure)-1):
                    #katman oluşturukuyor 
                    layer = hidden_layer(out,self.weights[k],structure[k+1]) 
                    #Katman girişleri ağırlıklar ile çarpılıp sigmoide sokuluyor
                    out = layer.ffw()
                    #Daha sonra kullanılmak için her çıkış ve tüm nöronlar kaydediliyor
                    all_outs.append(out)
                    all_neurons.append(layer.Neurons())
                #Çıkıştaki hata ve ortalama hata hesaplanıyor            
                error = train_data[j].target - out
                Error = error.dot(np.transpose(error))/2
                #Tüm datalar için error vektörleri ve ortalam hatalar kaydediliyor
                mean_errors[j] = Error
                error_vectors[:,j] = error
                #GERİYE YAYILIM
                #Son katmanın girişlerinin türevleri hesaplanıyor
                for i in range(structure[len(structure)-1]):
                    last_derivatives.append(sigmoid_derivative(all_neurons[len(structure)-2][i].dp(),5))
                    print(last_derivatives)
                #Son katmanın gradyanları hesaplanıyor ve tüm gradyanlar listesine ekleniyor
                last_gradients = last_derivatives * error
                all_gradients.append(last_gradients)
                #Son katmmandan önceki katmanların türevlerini ve sonrasında gradyanlarını bulunup kaydediliyor
                for i in range(len(structure)-2):
                    for j in range(structure[len(structure)-2-i]):
                        derivatives.append(sigmoid_derivative(all_neurons[len(structure)-3-i][j].dp(),5))
                    all_derivatives.append(derivatives)
                    #Gradyanın bulunması için sıradaki ağırlık matrisinden bias sütunu çıkarılıyor ve transpozu alınıyor
                    w = (self.weights[len(structure)-2-i])
                    without_bias = np.transpose(w[:,0:w.shape[1]-1]) 
                    transpose = np.transpose(all_gradients[i])
                    #Gradyan vektörü hesaplanıyor
                    gradients = (without_bias).dot(transpose)*derivatives
                    all_gradients.append(gradients)
                    #For içinde geçici olarak kullanılan listeler sonraki adım için boşaltılıyor
                    derivatives = []
                    gradients = []
                #Çıkışlar biassız olarak kaydedildiğinden bias ekleniyor
                for i in range(len(all_outs)-1):
                    all_outs[i] = np.insert(all_outs[i],structure[i],1)
                last_gradients = np.reshape(last_gradients,(-1,1))
                #Son ağırlıklar güncelleniyor
                temp_weights = self.weights[len(structure)-2] 
                self.weights[len(structure)-2] = self.weights[len(structure)-2] + (((last_gradients)*(all_outs[len(structure)-2])*self.c) + (self.weights_difference[len(structure)-2]*momentum))
                self.weights_difference[len(structure) - 2] = self.weights[len(structure)-2] - temp_weights
                #Son ağırlık matrisinden önceki ağırlıklar güncelleniyor
                for i in range(len(structure)-2):
                    all_gradients[i+1] = np.reshape(all_gradients[i+1],(-1,1))
                    #Ağırlıklar, ağırlık farkı bulmak için kullanılacağından yedekleniyor
                    temp_weights = self.weights[len(structure)-3-i]
                    self.weights[len(structure)-3-i] = self.weights[len(structure)-3-i] + (all_gradients[i+1])*((((all_outs[len(structure)-3-i]))))*self.c + (self.weights_difference[len(structure)-3-i]*momentum)
                    #Son ağırlıkları güncellerken input vektörü kullanılıyor, np.matrix np.array uyuşmazlığı olduğundan burada matrix çok boyutlu arraye döndürülüyor
                    self.weights[len(structure)-3-i] = np.squeeze(np.asarray(self.weights[len(structure)-3-i]))
                    #Ağırlık farkı momentum terimiyle kullanılacağından hesaplanıyor
                    self.weights_difference[len(structure)-3-i] = self.weights[len(structure)-3-i] - temp_weights
            #Durdurma kriteri için iki iterasyon sonundaki ortalama hata arasındaki fark hesaplanıyor
            stop = abs(np.mean(mean_errors) - stop)
            #print(a+1) -iterasyon sayıyor
            #print(out) -ağ çıkış vektörünü basıyor
            #Durdurma bölgesi
            if stop <= 1e-2 and a>50 :
                print("iteration number: ")
                print(a+1)
                return True
            if a == self.iteration:
                print("İteration number:",i+a)
                print("Maximum iteration done.")
                return False
    #Test metodu
    def test(self,test_data,structure):
        true = 0
        false = 0
        for j in range(len(test_data)):
            #Başlangıçta ilk data out olarak tanımlanıyor
            out = test_data[j].data 
            #İleri yayılım algoritası yapılan for döngüsü
            for k in range(len(structure)-1):
                #katman oluşturukuyor 
                layer = hidden_layer(out,self.weights[k],structure[k+1]) 
                #Katman girişleri ağırlıklar ile çarpılıp sigmoide sokuluyor
                out = layer.ffw()
            #Error vekötünün mutlak değeri en büyük elemanı error olarak atanıyor, epsilon değerinden küçük ise doğru sayılacak  
            error = max(abs(test_data[j].target- out)) 
            #print(error)
            if error <= 0.05:
                true += 1
            else:
                false += 1
        print("Number of true data:",true)
#Data ve targetı beraber tutan class
class data_with_class(object):
    def __init__(self,data,target):
        self.data = data
        self.target = target

if __name__ == '__main__':
    #Eğitim ve test dataları oluşturuluyor
    train_data = create_train()
    test_data = create_test()
    #random.shuffle(train_data)
    #Çok katmanlı algılayıcı oluşturuluyor
    mlp = ml_per(0.05,3000)
    #Ağ yapısı belirleniyor, 50 giriş, 4 çıkış, sırayla katmanlarda 48,29,20,4 nöron.
    structure = [50,48,29,20,4]
    #Momentum katsayısı
    momentum = 0.2
    #Train yapılıyor, başarılı olursa teste sokuluyor.
    train = mlp.train(train_data,structure,momentum)
    if train:
        mlp.test(test_data,structure)
    else:
        print("Data will not be tested.")





